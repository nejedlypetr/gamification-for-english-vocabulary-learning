\chapter{Implementation}

This chapter presents the technical implementation of the gamification features proposed in Chapter \ref{chap:proposed-solution-design} and validated through user testing in Chapter \ref{chap:prototype-user-testing}. The implementation process was structured to ensure both technical feasibility and alignment with the application's existing architecture while maintaining the core pedagogical principles of English Mind.

The chapter begins with an analysis of the current system architecture, providing context for the technical decisions made during implementation. Following this, we introduce a monorepo architecture solution that enables parallel development of the prototype and main application. This approach allows for rapid iteration and testing of new features without disrupting the production environment. Finally, we detail the implementation of selected gamification features, focusing on technical considerations, integration challenges, and solutions adopted.

\section{Existing System Architecture}
\label{sec:existing-system-architecture}

English Mind is built using the Flutter framework, chosen for its cross-platform capabilities and robust widget system. The application follows a modular architecture inspired by Clean Architecture principles, ensuring separation of concerns and maintainability. This section provides a comprehensive overview of the current system architecture, detailing the technology stack, architectural patterns, and key system components.
\newpage
\subsection{Technology Stack}

The application is built using the Flutter framework, chosen for its cross-platform capabilities and robust widget system. This choice enables the development of a single codebase that runs seamlessly on both iOS and Android platforms while maintaining native-like performance and user experience. The decision to use Flutter was driven by its ability to deliver consistent user interfaces across platforms while maintaining high performance, as demonstrated by its successful implementation in numerous production applications \cite{cite:google_flutter_case_studies}.

The data management strategy combines cloud-based and local storage solutions to balance performance, offline capability, and real-time synchronization requirements. Firebase Firestore serves as the primary cloud storage solution, providing real-time data synchronization and a NoSQL document database. This choice was made to leverage Firestore's built-in offline persistence and real-time updates, which are crucial for maintaining user progress across devices. For translation services, the application integrates with the Microsoft Translator API, selected for its high accuracy and extensive language support. The vocabulary data is stored locally in a JSON file containing word definitions and sentence examples, a design decision that ensures immediate access to core content without network dependency and reduces server load.

The application leverages several key Flutter/Dart packages to enhance functionality and maintainability:
\begin{itemize}
    \item \textbf{get\_it} - Dependency injection framework for managing object creation and lifetime.
    \item \textbf{flutter\_hooks} - State management solution chosen for its simplicity and performance benefits over traditional state management approaches.
    \item \textbf{auto\_route} - Navigation and routing system that provides type-safe routing and reduces boilerplate code.
    \item \textbf{objectbox} - Local storage solution for efficient data management.
    \item \textbf{sign\_in\_with\_apple} and \textbf{google\_sign\_in} - Third-party authentication providers.
    \item \textbf{firebase\_auth} - User authentication service providing secure user management.
    \item \textbf{firebase\_functions} - Cloud functions for serverless computing, enabling scalable backend operations.
    \item \textbf{firebase\_firestore} - Cloud storage for real-time data synchronization and offline persistence.
    \item \textbf{flutter\_localizations} - Localization framework enabling internationalization support.
\end{itemize}

\subsection{Architectural Overview}

The application follows Clean Architecture principles with a clear separation of concerns across distinct layers, while incorporating custom architectural decisions to better suit the application's specific needs. The architecture is designed to maintain high maintainability and scalability while ensuring a unidirectional data flow. The codebase is organized into the following directory structure, each serving a specific purpose in the application's architecture:

\begin{itemize}
    \item \texttt{core/} – Provides shared utilities and common functionality.
    \begin{itemize}
        \item \texttt{constants/} – Application-wide constants and shared values.
        \item \texttt{extensions/} – Dart language extensions providing additional functionality.
        \item \texttt{injector/} – Dependency injection configuration and service registration.
        \item \texttt{l10n/} – Internationalization and localization support.
        \item \texttt{logger/} – Application logging functionality and utilities.
        \item \texttt{routes/} – Application navigation and routing configuration.
        \item \texttt{utils/} – Utility functions and helpers.
    \end{itemize}

    \item \texttt{domain/} – Contains the core business logic and is implementation independent.
    \begin{itemize}
        \item \texttt{entities/} – Core business objects representing the domain model.
        \item \texttt{managers/} – Business logic orchestrators and state managers.
        \item \texttt{repositories/} – Abstract interfaces defining data operations.
        \item \texttt{usecases/} – Core business operations and rules between entities and repositories.
    \end{itemize}
    
    \item \texttt{data/} – Handles data operations and implementations of repository interfaces.
    \begin{itemize}
        \item \texttt{models/} – Data models and transformations.
        \item \texttt{repositories/} – Concrete implementations of repository interfaces.
        \item \texttt{mappers/} – Transformation logic between domain entities and data models.
    \end{itemize}
    
    \item \texttt{ui/} – Presentation layer managing user interface components and interactions.
    \begin{itemize}
        \item \texttt{theme/} – UI theme configuration and styling.
        \item \texttt{screens/} – Screen-specific UI components and layouts.
        \item \texttt{widgets/} – Reusable UI components.
        \item \texttt{hooks/} – UI-specific hooks for state management and resource handling within widgets.
    \end{itemize}
\end{itemize}


\section{New Monorepo Architecture}
\label{sec:new-monorepo-architecture}

\section{Features Implementation}
\label{sec:features-implementation}